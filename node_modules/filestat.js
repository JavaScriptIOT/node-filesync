(function () {
	"use strict";

	var crypto = require('crypto'),
		hashAlgo = "md5",
		fs = require('fs');

	function FileStat() {
		var self;

		function checkMd5(callback) {
			var hash, error,
				hashData = self.mtime.toString() + self.size.toString() + self.path;

			if (!(self.path && self.mtime && self.size)) {
				callback("Something is missing, can't compute hash");
				return;
			}

			hash = crypto.createHash(hashAlgo).update(hashData).digest("hex");
			if (!self.qmd5) {
				error = "No qmd5";
			} else if (self.qmd5 !== hash) {
				error = "Hash doesn't match";
			} else {
				self.qmd5 = hash;
			}

			callback(error, hash);
		}

		function genTmd5(cb) {
			var hash, half, quarter, check;

			if (self.size <= 4096 * 10) {
				if (self.md5) {
					return cb(null, self.md5);
				}

				fs.readFile(self.origPath, function (err, data) {
					var tmd5;
					if (!err) {
						tmd5 = crypto.createHash("md5").update(data).digest("hex");
						self.tmd5 = tmd5;
						return cb(null, tmd5);
					}
					return cb(err);
				});
			}

			hash = crypto.createHash("md5");
			half = Math.floor(self.size / 2);
			quarter = Math.floor(half / 2);
			check = [
				0,
				quarter,
				half,
				half + quarter,
				self.size - 4096
			];

			check.forEachAsync(function (next, pos) {
				fs.read(self.path, pos, 4096, function (err, data) {
					hash.update(data);
					next();
				});
			}).then(function () {
				return cb(null, hash.digest('hex'));
			});
		}

		this.checkMd5 = checkMd5;
		this.genTmd5 = genTmd5;
		self = this;
	}

	module.exports = FileStat;
}());
